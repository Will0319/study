# 接口 interface

## TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。

## 目录
1. [可选属性 & 只读属性](https://github.com/Will0319/study/blob/master/TypeScript/接口.md#可选属性--只读属性) 

### 可选属性 & 只读属性
#### 1.可选属性  
```
interface Square {
    color: string
    area: number
}

interface SquareConfig {
    // ？表示为可选属性
    color?: string
    width?: number
}

function createSquare(config: SquareConfig): Square {
    // 默认值
    let newSquare = {color: 'white', area: 100}
    if (config.color) {
        newSquare.color = config.color
    }
    if (config.width) {
        newSquare.area = config.width * config.width
    }
    return newSquare
}

let mySquare = createSquare({color: 'black'})
// console.log(mySquare)
```
根据代码可以看出可选属性的优点及使用处  
（1）可以对可能存在的属性做预定义  
（2）可以捕获不存在属性的一些错误，如拼写错误等  

#### 2.只读属性 
有些对象它的属性只有在创建的时候修改它的值，这个时候就应该使用只读属性  
一个最简单的实例：  
```
interface Point {
    readonly x: number
    readonly y: number
}
// 创建后x和y就不能改变了
let p: Point = {x: 10, y: 10}
// 这个时候就会报错，不能够修改只读属性了
p.x = 3
```
Ts具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改
```
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```
上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写
```
a = ro as number[];
```
可以发现这个用法和ES6中的赋值const很相似，那么该怎么判断应该使用const还是readonly呢？最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。